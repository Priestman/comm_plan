function checkDuplicateTracks() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const timeZone = Session.getScriptTimeZone() || "Europe/Moscow"; // –ó–∞–ø–∞—Å–Ω–∞—è –≤—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞
  const now = new Date();
  now.setHours(19, 58, 0, 0); // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è (07:58 PM CEST)

  // –õ–æ–≥–∏—Ä—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –∑–æ–Ω—É –∏ –¥–∞—Ç—ã
  Logger.log(`‚ÑπÔ∏è –í—Ä–µ–º–µ–Ω–Ω–∞—è –∑–æ–Ω–∞ —Å–∫—Ä–∏–ø—Ç–∞: ${timeZone}`);
  Logger.log(`‚ÑπÔ∏è –¢–µ–∫—É—â–∞—è –¥–∞—Ç–∞: ${now}`);

  const currentMonthName = Utilities.formatDate(now, timeZone, "MMMM_yyyy");
  Logger.log(`‚ÑπÔ∏è –¢–µ–∫—É—â–∏–π –º–µ—Å—è—Ü: ${currentMonthName}`);

  const prevDate = new Date(now);
  prevDate.setMonth(prevDate.getMonth() - 1);
  const previousMonthName = Utilities.formatDate(prevDate, timeZone, "MMMM_yyyy");
  Logger.log(`‚ÑπÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∏–π –º–µ—Å—è—Ü: ${previousMonthName}`);

  const nextDate = new Date(now);
  nextDate.setMonth(nextDate.getMonth() + 1);
  const nextMonthName = Utilities.formatDate(nextDate, timeZone, "MMMM_yyyy");
  Logger.log(`‚ÑπÔ∏è –°–ª–µ–¥—É—é—â–∏–π –º–µ—Å—è—Ü: ${nextMonthName}`);

  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –∏–º–µ–Ω–∞ –º–µ—Å—è—Ü–µ–≤
  const monthsToCollect = [previousMonthName, currentMonthName, nextMonthName].filter(name => name && name !== "undefined");
  if (monthsToCollect.length === 0) {
    Logger.log(`‚ùå –û—à–∏–±–∫–∞: –Ω–∏ –æ–¥–Ω–æ –∏–º—è –º–µ—Å—è—Ü–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ.`);
    return;
  }

  const validSheetPattern = /^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/;

  const allTracks = new Map();

  // –°–±–æ—Ä –≤—Å–µ—Ö —Ç—Ä–µ–∫–æ–≤ –∑–∞ 3 –º–µ—Å—è—Ü–∞
  monthsToCollect.forEach(monthName => {
    Logger.log(`‚ÑπÔ∏è –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏—Å—Ç–∞ –¥–ª—è —Å–±–æ—Ä–∞ —Ç—Ä–µ–∫–æ–≤: ${monthName}`);
    const sheet = spreadsheet.getSheetByName(monthName);
    if (!sheet || !validSheetPattern.test(monthName)) { // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–ª—å–∫–æ –∏–º—è, —Ç–∞–∫ –∫–∞–∫ –ª–∏—Å—Ç –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å
      Logger.log(`‚ÑπÔ∏è –õ–∏—Å—Ç '${monthName}' –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è. –ü—Ä–æ–ø—É—Å–∫ —Å–±–æ—Ä–∞ —Ç—Ä–µ–∫–æ–≤.`);
      return;
    }

    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) {
      Logger.log(`‚ÑπÔ∏è –õ–∏—Å—Ç '${monthName}' –ø—É—Å—Ç –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –∑–∞–≥–æ–ª–æ–≤–∫–∏. –ü—Ä–æ–ø—É—Å–∫ —Å–±–æ—Ä–∞ —Ç—Ä–µ–∫–æ–≤.`);
      return;
    }

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const trackCol = headers.indexOf("–¢—Ä–µ–∫") + 1;
    const statusCol = headers.indexOf("–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏") + 1;

    if (trackCol < 1 || statusCol < 1) {
      Logger.log(`‚ùå –í –ª–∏—Å—Ç–µ '${monthName}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã —Å—Ç–æ–ª–±—Ü—ã "–¢—Ä–µ–∫" –∏–ª–∏ "–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏". –ü—Ä–æ–ø—É—Å–∫ —Å–±–æ—Ä–∞.`);
      return;
    }

    const trackValues = sheet.getRange(2, trackCol, lastRow - 1, 1).getValues();
    const statusValues = sheet.getRange(2, statusCol, lastRow - 1, 1).getValues();

    trackValues.forEach((row, idx) => {
      const track = row[0]?.toString().trim();
      const status = statusValues[idx][0]?.toString().trim();
      const sheetRowNumber = idx + 2;

      if (!track || status === "–û—Ç–º–µ–Ω–µ–Ω–∞" || status === "–ù–µ —É—à–ª–∞") return;

      const normalized = extractTrackId(track);
      if (!normalized) return;

      if (!allTracks.has(normalized)) allTracks.set(normalized, []);
      allTracks.get(normalized).push({ month: monthName, trackRow: sheetRowNumber });
    });
  });

  // –ó–∞–ø—É—Å–∫ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –º–µ—Å—è—Ü–µ–≤
  const monthsToProcessForGeneration = [currentMonthName, nextMonthName].filter(name => name && name !== "undefined");
  if (monthsToProcessForGeneration.length === 0) {
    Logger.log(`‚ùå –û—à–∏–±–∫–∞: –Ω–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö –º–µ—Å—è—Ü–µ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (currentMonthName: ${currentMonthName}, nextMonthName: ${nextMonthName}).`);
    return;
  }

  monthsToProcessForGeneration.forEach(targetMonthName => {
    Logger.log(`‚ÑπÔ∏è –ù–∞—á–∞–ª–æ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ª–∏—Å—Ç–∞: ${targetMonthName}`);
    try {
      processSheetForTracks(spreadsheet, targetMonthName, allTracks, validSheetPattern, timeZone);
    } catch (e) {
      Logger.log(`‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –ª–∏—Å—Ç–∞ '${targetMonthName}': ${e.message}`);
    }
    Logger.log(`‚ÑπÔ∏è –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ª–∏—Å—Ç–∞: ${targetMonthName}`);
  });

  Logger.log("‚úÖ –û–±—â–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç—Ä–µ–∫–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.");
}

function processSheetForTracks(spreadsheet, sheetName, allTracksMap, validSheetPattern, timeZone) {
  Logger.log(`‚öôÔ∏è –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏—Å—Ç–∞: '${sheetName}' –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏...`);
  if (!sheetName || sheetName === "undefined") {
    Logger.log(`‚ùå –û—à–∏–±–∫–∞: sheetName –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ (${sheetName}). –ü—Ä–æ–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏.`);
    return;
  }

  const sheet = spreadsheet.getSheetByName(sheetName);
  if (!sheet || !validSheetPattern.test(sheet.getName())) {
    Logger.log(`‚ö† –õ–∏—Å—Ç '${sheetName}' –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∏–º—è. –ü—Ä–æ–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏.`);
    return;
  }

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const trackCol = headers.indexOf("–¢—Ä–µ–∫") + 1;
  const statusCol = headers.indexOf("–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏") + 1;
  const correctnessCol = headers.indexOf("–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å—Ç—Ä–æ–∫–∏") + 1;
  const autoGenCol = headers.indexOf("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç—Ä–µ–∫") + 1;

  if (trackCol < 1 || statusCol < 1 || correctnessCol < 1 || autoGenCol < 1) {
    Logger.log(`‚ùå –í –ª–∏—Å—Ç–µ '${sheetName}' –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –Ω—É–∂–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã. –ü—Ä–æ–ø—É—Å–∫.`);
    return;
  }

  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    Logger.log(`‚ÑπÔ∏è –õ–∏—Å—Ç '${sheetName}' –ø—É—Å—Ç –∏–ª–∏ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–æ–ª—å–∫–æ –∑–∞–≥–æ–ª–æ–≤–∫–∏. –ü—Ä–æ–ø—É—Å–∫.`);
    return;
  }

  // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  const trackValues = sheet.getRange(2, trackCol, lastRow - 1, 1).getValues();
  const statusValues = sheet.getRange(2, statusCol, lastRow - 1, 1).getValues();
  const correctnessValues = sheet.getRange(2, correctnessCol, lastRow - 1, 1).getValues();
  const autoGenValues = sheet.getRange(2, autoGenCol, lastRow - 1, 1).getValues();

  // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  const originalTrackValues = trackValues.map(row => [row[0]]);
  const originalCorrectnessValues = correctnessValues.map(row => [row[0]]);

  // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
  const changedTracks = [];
  const changedCorrectness = [];

  const usedTridsInCurrentProcessingSheet = new Set();
  const monthNumberForThisSheet = getMonthNumber(sheetName);

  for (let i = 0; i < trackValues.length; i++) {
    const rawTrack = trackValues[i][0]?.toString().trim();
    const status = statusValues[i][0]?.toString().trim();
    const autoGen = autoGenValues[i][0]?.toString().toLowerCase().trim();
    const currentRowNumber = i + 2;

    const normalizedTrackId = extractTrackId(rawTrack);

    const globalDuplicates = allTracksMap.get(normalizedTrackId)?.filter(
        entry => entry.month !== sheetName || entry.trackRow !== currentRowNumber
    );
    const hasGlobalDuplicates = globalDuplicates && globalDuplicates.length > 0;

    const hasLocalDuplicateInThisRun = normalizedTrackId && usedTridsInCurrentProcessingSheet.has(normalizedTrackId);

    const isTrackValidFormat = isTrackValid(normalizedTrackId, monthNumberForThisSheet);

    if (status === "–í—ã–ø–æ–ª–Ω–µ–Ω–∞" || status === "–°–æ–≥–ª–∞—Å–æ–≤–∞–Ω–æ") {
      let newCorrectnessValue = "";
      
      if (hasGlobalDuplicates) {
        newCorrectnessValue = `‚ùå –î—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ç—Ä–µ–∫ (–≥–ª–æ–±–∞–ª—å–Ω—ã–π), –Ω–æ —Å—Ç—Ä–æ–∫–∞ –∑–∞—â–∏—â–µ–Ω–∞: ${globalDuplicates.map(d => `${d.month} (—Å—Ç—Ä–æ–∫–∞ ${d.trackRow})`).join(", ")}`;
      } else if (hasLocalDuplicateInThisRun) {
        newCorrectnessValue = `‚ùå –î—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ç—Ä–µ–∫ (–≤ —Ç–µ–∫—É—â–µ–º –ª–∏—Å—Ç–µ), –Ω–æ —Å—Ç—Ä–æ–∫–∞ –∑–∞—â–∏—â–µ–Ω–∞`;
      } else if (correctnessValues[i][0] !== "–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ –ë–î") {
        newCorrectnessValue = "";
      } else {
        newCorrectnessValue = correctnessValues[i][0]; // –û—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –±—ã–ª–æ
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏
      if (newCorrectnessValue !== originalCorrectnessValues[i][0]) {
        correctnessValues[i][0] = newCorrectnessValue;
        changedCorrectness.push({
          row: currentRowNumber,
          value: newCorrectnessValue,
          oldValue: originalCorrectnessValues[i][0]
        });
      }
      
      if (normalizedTrackId) {
        usedTridsInCurrentProcessingSheet.add(normalizedTrackId);
        if (!allTracksMap.has(normalizedTrackId) || !allTracksMap.get(normalizedTrackId).some(e => e.month === sheetName && e.trackRow === currentRowNumber)) {
          allTracksMap.set(normalizedTrackId, (allTracksMap.get(normalizedTrackId) || []).concat({month: sheetName, trackRow: currentRowNumber}));
        }
      }
      continue;
    }

    const shouldGenerate = autoGen === "–¥–∞" && (!rawTrack || !isTrackValidFormat || hasGlobalDuplicates || hasLocalDuplicateInThisRun);

    if (shouldGenerate) {
      const { fullTrack, normalized: newGeneratedTrid } = generateUniqueTrack(monthNumberForThisSheet, usedTridsInCurrentProcessingSheet);
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª—Å—è –ª–∏ —Ç—Ä–µ–∫
      if (fullTrack !== originalTrackValues[i][0]) {
        trackValues[i][0] = fullTrack;
        changedTracks.push({
          row: currentRowNumber,
          value: fullTrack,
          oldValue: originalTrackValues[i][0],
          action: 'generated'
        });
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–∞—Å—å –ª–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å
      if (correctnessValues[i][0] !== "") {
        correctnessValues[i][0] = "";
        changedCorrectness.push({
          row: currentRowNumber,
          value: "",
          oldValue: originalCorrectnessValues[i][0],
          action: 'cleared'
        });
      }
      
      usedTridsInCurrentProcessingSheet.add(newGeneratedTrid);
      if (!allTracksMap.has(newGeneratedTrid)) {
        allTracksMap.set(newGeneratedTrid, []);
      }
      allTracksMap.get(newGeneratedTrid).push({ month: sheetName, trackRow: currentRowNumber });
    } else {
      let newCorrectnessValue = "";
      
      if (normalizedTrackId) {
        usedTridsInCurrentProcessingSheet.add(normalizedTrackId);
        if (!isTrackValidFormat) {
          newCorrectnessValue = "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ç—Ä–µ–∫–∞";
        } else if (hasGlobalDuplicates) {
          newCorrectnessValue = `‚ùå –î—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ç—Ä–µ–∫ –≤ ${globalDuplicates.map(d => `${d.month} (—Å—Ç—Ä–æ–∫–∞ ${d.trackRow})`).join(", ")}`;
        } else if (hasLocalDuplicateInThisRun) {
          newCorrectnessValue = `‚ùå –î—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ç—Ä–µ–∫ –≤ —Ç–µ–∫—É—â–µ–º –ª–∏—Å—Ç–µ`;
        } else {
          newCorrectnessValue = "";
        }
      } else {
        if (autoGen !== "–¥–∞") {
          newCorrectnessValue = "‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç—Ä–µ–∫–∞";
        }
      }
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏–∑–º–µ–Ω–∏–ª–æ—Å—å –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏
      if (newCorrectnessValue !== originalCorrectnessValues[i][0]) {
        correctnessValues[i][0] = newCorrectnessValue;
        changedCorrectness.push({
          row: currentRowNumber,
          value: newCorrectnessValue,
          oldValue: originalCorrectnessValues[i][0],
          action: 'validation'
        });
      }
    }
  }

  // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
  let trackChangesCount = 0;
  let correctnessChangesCount = 0;

  if (changedTracks.length > 0) {
    changedTracks.forEach(change => {
      try {
        sheet.getRange(change.row, trackCol).setValue(change.value);
        trackChangesCount++;
        Logger.log(`üîÑ –°—Ç—Ä–æ–∫–∞ ${change.row}: —Ç—Ä–µ–∫ "${change.oldValue}" ‚Üí "${change.value}" (${change.action})`);
      } catch (error) {
        Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ —Ç—Ä–µ–∫–∞ –≤ —Å—Ç—Ä–æ–∫—É ${change.row}: ${error.toString()}`);
      }
    });
  }

  if (changedCorrectness.length > 0) {
    changedCorrectness.forEach(change => {
      try {
        sheet.getRange(change.row, correctnessCol).setValue(change.value);
        correctnessChangesCount++;
        if (change.action) {
          Logger.log(`üîÑ –°—Ç—Ä–æ–∫–∞ ${change.row}: –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å "${change.oldValue}" ‚Üí "${change.value}" (${change.action})`);
        }
      } catch (error) {
        Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –≤ —Å—Ç—Ä–æ–∫—É ${change.row}: ${error.toString()}`);
      }
    });
  }

  // –ò—Ç–æ–≥–æ–≤–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
  if (trackChangesCount > 0 || correctnessChangesCount > 0) {
    Logger.log(`‚úÖ –õ–∏—Å—Ç '${sheetName}': –æ–±–Ω–æ–≤–ª–µ–Ω–æ —Ç—Ä–µ–∫–æ–≤: ${trackChangesCount}, –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏: ${correctnessChangesCount}`);
  } else {
    Logger.log(`‚ÑπÔ∏è –õ–∏—Å—Ç '${sheetName}': –∏–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è (–≤—Å–µ –¥–∞–Ω–Ω—ã–µ –∞–∫—Ç—É–∞–ª—å–Ω—ã)`);
  }

  Logger.log(`‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–ª—è –ª–∏—Å—Ç–∞ '${sheetName}' –∑–∞–≤–µ—Ä—à–µ–Ω–∞.`);
}

function extractTrackId(track) {
  if (!track) return null;
  const match = track.match(/(?:\?|&)trid=([^&]*)/);
  return match && match[1]?.trim() ? match[1].trim() : null;
}

function isTrackValid(trackId, monthNumber) {
  return trackId ? new RegExp(`^crvp${monthNumber}[A-Z0-9]{6}$`).test(trackId) : false;
}

function generateUniqueTrack(monthNumber, usedTrids, maxAttempts = 100) {
  let attempt = 0;
  let newTrack, normalized;

  do {
    const randomStr = Math.random().toString(36).substring(2, 8).toUpperCase();
    normalized = `crvp${monthNumber}${randomStr}`;
    attempt++;
    if (attempt >= maxAttempts) {
      Logger.log(`‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫ –ø–æ—Å–ª–µ ${maxAttempts} –ø–æ–ø—ã—Ç–æ–∫. –í–æ–∑–º–æ–∂–Ω–æ, –∏—Å—á–µ—Ä–ø–∞–Ω—ã –¥–æ—Å—Ç—É–ø–Ω—ã–µ ID.`);
      return { fullTrack: "?trid=GENERATION_FAILED", normalized: "GENERATION_FAILED" };
    }
  } while (usedTrids.has(normalized));

  return {
    fullTrack: `?trid=${normalized}`,
    normalized
  };
}

function getMonthNumber(sheetName) {
  const [monthName] = sheetName.split("_");
  const months = {
    January: "1", February: "2", March: "3", April: "4", May: "5",
    June: "6", July: "7", August: "8", September: "9", October: "10",
    November: "11", December: "12"
  };
  const number = months[monthName];
  if (!number) {
    Logger.log(`‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –Ω–æ–º–µ—Ä –º–µ—Å—è—Ü–∞ –¥–ª—è –∏–º–µ–Ω–∏ –ª–∏—Å—Ç–∞: '${sheetName}'`);
    return "0";
  }
  return number;
}
