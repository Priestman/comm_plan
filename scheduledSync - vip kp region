function scheduledSync() {
  Logger.log("üöÄ [START] –ó–∞–ø—É—Å–∫ scheduledSync()");

  const ss = SpreadsheetApp.openById('1cuuCfjbtAPbEtXd0f6cYC8OEAnMeoF2-l44NamqZaV8');
  const timeZone = Session.getScriptTimeZone();
  const today = new Date();

  const currentMonth = Utilities.formatDate(today, timeZone, "MMMM_yyyy");
  const nextMonthDate = new Date(today.getFullYear(), today.getMonth() + 1, 1);
  const nextMonth = Utilities.formatDate(nextMonthDate, timeZone, "MMMM_yyyy");

  const sheetsToProcess = [currentMonth]; // —Ç–µ–∫—É—â–∏–π –¥–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ–≥–¥–∞

    Logger.log("üèÅ –í—Å–µ –ª–∏—Å—Ç—ã –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã.");

  Logger.log("DEBUG: currentMonth = " + currentMonth);
Logger.log("DEBUG: nextMonth = " + nextMonth);
Logger.log("DEBUG: ss = " + (ss ? "OK" : "undefined/null"));
Logger.log("DEBUG: sheetsToProcess = " + JSON.stringify(sheetsToProcess));

  const hasNext = ss.getSheetByName(nextMonth);
  if (hasNext) {
    sheetsToProcess.push(nextMonth);
    Logger.log(`üìÖ –ù–∞–π–¥–µ–Ω –∏ —Å–ª–µ–¥—É—é—â–∏–π –º–µ—Å—è—Ü: ${nextMonth}`);
  }

  sheetsToProcess.forEach(sheetName => {
    Logger.log(`üîÑ –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ª–∏—Å—Ç: ${sheetName}`);
    processMonthSheet(ss, sheetName);
  });

}

function processMonthSheet(ss, sheetName) {
  const sheet = ss.getSheetByName(sheetName);
  if (!sheet) return Logger.log(`‚ö† –õ–∏—Å—Ç ${sheetName} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);

  Logger.log(`üìÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏—Å—Ç–∞: ${sheetName}`);

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];

  hardRepairProcessLabels(sheet, headers);

  const col = name => headers.indexOf(name) + 1;
  const geoCol = col("–ì–ï–û");
  const mirrorCol = col("–ó–µ—Ä–∫–∞–ª–æ");
  const pathCol = col("–ü—É—Ç—å");
  const trackCol = col("–¢—Ä–µ–∫");
  const linkTrackCol = col("–°—Å—ã–ª–∫–∞ + —Ç—Ä–µ–∫");
  const refGeoCol = col("–ì–ï–û");
  const refChannelCol = col("–ö–∞–Ω–∞–ª");
  const refTimeCol = col("–í—Ä–µ–º—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ –ú–°–ö");
  const geoNCol = col("–ì–µ–æ_N");
  const channelNCol = col("–ö–∞–Ω–∞–ª_N");
  const timeNCol = col("–í—Ä–µ–º—è_N");
  const refprocessCol = col("process_lable");
  const segmentCol = col("–°–µ–≥–º–µ–Ω—Ç_N");
  const textCol = col("–¢–µ–∫—Å—Ç");
  const textSourceCol = col("–°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–µ–∫—Å—Ç");
  const channelCol = col("–ö–∞–Ω–∞–ª");

  if (!geoCol || !mirrorCol || !pathCol || !trackCol || !linkTrackCol || !geoNCol || !channelNCol || !timeNCol || !refprocessCol || !segmentCol || !textCol || !textSourceCol || !channelCol)
    return Logger.log(`‚ö† –ù–µ –≤—Å–µ –Ω—É–∂–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã –Ω–∞–π–¥–µ–Ω—ã –Ω–∞ –ª–∏—Å—Ç–µ ${sheetName}.`);

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return Logger.log(`‚ö† –í –ª–∏—Å—Ç–µ ${sheetName} –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö.`);

  const geoValues = sheet.getRange(2, geoCol, lastRow - 1, 1).getValues();
  const mirrorValues = sheet.getRange(2, mirrorCol, lastRow - 1, 1).getValues();
  const pathValues = sheet.getRange(2, pathCol, lastRow - 1, 1).getValues();
  const trackValues = sheet.getRange(2, trackCol, lastRow - 1, 1).getValues();
  const channelValues = sheet.getRange(2, channelCol, lastRow - 1, 1).getValues();
  const textSourceValues = sheet.getRange(2, textSourceCol, lastRow - 1, 1).getValues();

  const geoMirrorCache = JSON.parse(PropertiesService.getScriptProperties().getProperty("geo_mirror_cache") || "{}");

  const textFormulas = [], mirrorUpdates = [], linkTrackUpdates = [];
  const geoFormulas = [], channelFormulas = [], timeFormulas = [], processFormulas = [];

  // ‚úÖ –î–û–ë–ê–í–õ–ï–ù–ù–ê–Ø –ß–ê–°–¢–¨ ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ "–¢—Ä–µ–∫", –µ—Å–ª–∏ –æ–Ω –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç ?trid= –∏–ª–∏ &trid=
const updatedTrackValues = [];
let hasRealChange = false;

for (let i = 0; i < lastRow - 1; i++) {
  let originalTrack = trackValues[i][0]?.toString().trim() || "";
  const path = pathValues[i][0]?.toString().trim() || "";

  if (!originalTrack) {
    updatedTrackValues.push([originalTrack]);
    continue;
  }

  let newTrack = originalTrack;
  const hasTrid = /\?(trid=)/.test(originalTrack) || /&(trid=)/.test(originalTrack);

  if (!hasTrid) {
    const delim = path.includes("?") ? "&" : "?";
    const clean = originalTrack.replace(/^[\?&]?/, '');
    newTrack = `${delim}trid=${clean}`;
  } else {
    const pathHasQuery = path.includes("?");
    if (originalTrack.startsWith("?trid=") && pathHasQuery) {
      newTrack = originalTrack.replace("?trid=", "&trid=");
    }
    if (originalTrack.startsWith("&trid=") && !pathHasQuery) {
      newTrack = originalTrack.replace("&trid=", "?trid=");
    }
  }

  if (newTrack !== originalTrack) {
    hasRealChange = true;
    trackValues[i][0] = newTrack;
  }

  updatedTrackValues.push([newTrack]);
}

// üíæ –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–µ–∞–ª—å–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
if (hasRealChange) {
  sheet.getRange(2, trackCol, updatedTrackValues.length, 1).setValues(updatedTrackValues);
  Logger.log("üìå –û–±–Ω–æ–≤–ª–µ–Ω—ã –∑–Ω–∞—á–µ–Ω–∏—è –≤ –∫–æ–ª–æ–Ω–∫–µ '–¢—Ä–µ–∫'");
} else {
  Logger.log("‚úÖ –ù–∏–∫–∞–∫–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ '–¢—Ä–µ–∫' –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è");
}


  // üì¶ –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ (–Ω–µ –º–µ–Ω—è–µ–º)
  for (let i = 0; i < lastRow - 1; i++) {
    const geo = geoValues[i][0]?.toString().trim().toUpperCase();
    const mirror = mirrorValues[i][0]?.toString().trim() || "";
    const path = pathValues[i][0]?.toString().trim() || "";
    const track = trackValues[i][0]?.toString().trim() || "";
    const channel = channelValues[i][0];

    let mirrorToUse = mirror;
    if (geo && !geo.includes(",") && geoMirrorCache[geo]) {
      const expectedMirror = geoMirrorCache[geo];
      const isCustomTmePath = path.includes("t.me") || path.includes("/t.me/");
      if (mirror !== expectedMirror && !isCustomTmePath) {
        mirrorToUse = expectedMirror;
      }
    } else {
      mirrorToUse = "";
    }

    mirrorUpdates.push([mirrorToUse]);
    linkTrackUpdates.push([(mirrorToUse || "") + path + track]);

    const textCell = sheet.getRange(i + 2, textSourceCol).getA1Notation();
    const linkCell = sheet.getRange(i + 2, linkTrackCol).getA1Notation();
    if (channel === "Telegram" || channel === "Whatsapp" || channel === "WA/TG/SMS") {
      textFormulas.push([`=${textCell}&CHAR(10)&${linkCell}`]);
    } else if (channel === "SMS") {
      textFormulas.push([`=${textCell}&" "&${linkCell}`]);
    } else {
      textFormulas.push([""]);
    }

    geoFormulas.push([`=${sheet.getRange(i + 2, refGeoCol).getA1Notation()}`]);
    channelFormulas.push([`=${sheet.getRange(i + 2, refChannelCol).getA1Notation()}`]);
    timeFormulas.push([`=${sheet.getRange(i + 2, refTimeCol).getA1Notation()}`]);
    processFormulas.push([`=${sheet.getRange(i + 2, refprocessCol).getA1Notation()}`]);
  }

  // üíæ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π
  sheet.getRange(2, mirrorCol, mirrorUpdates.length, 1).setValues(mirrorUpdates);
  sheet.getRange(2, linkTrackCol, linkTrackUpdates.length, 1).setValues(linkTrackUpdates);
  sheet.getRange(2, geoNCol, geoFormulas.length, 1).setFormulas(geoFormulas);
  sheet.getRange(2, channelNCol, channelFormulas.length, 1).setFormulas(channelFormulas);
  sheet.getRange(2, timeNCol, timeFormulas.length, 1).setFormulas(timeFormulas);
  sheet.getRange(2, segmentCol, processFormulas.length, 1).setFormulas(processFormulas);
  sheet.getRange(2, textCol, textFormulas.length, 1).setFormulas(textFormulas);

  Logger.log(`‚úÖ –õ–∏—Å—Ç ${sheetName} —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω.`);
}

function hardRepairProcessLabels(sheet, headers) {
  const col = name => headers.indexOf(name) + 1;

  const dateCol   = col("–î–∞—Ç–∞");
  const chanCol   = col("–ö–∞–Ω–∞–ª");
  const statusCol = col("–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏");
  const labelCol  = col("process_lable");

  if (!(dateCol && chanCol && statusCol && labelCol)) {
    Logger.log("‚ö† hardRepairProcessLabels: –Ω–µ—Ç –∫–ª—é—á–µ–≤—ã—Ö –∫–æ–ª–æ–Ω–æ–∫ (–î–∞—Ç–∞/–ö–∞–Ω–∞–ª/–°—Ç–∞—Ç—É—Å/process_lable). –ü—Ä–æ–ø—É—Å–∫.");
    return;
  }

  const FIRST = 2;
  const lastRow = sheet.getLastRow();
  const n = lastRow - FIRST + 1;
  if (n <= 0) return;

  const tz = Session.getScriptTimeZone();

  const dates   = sheet.getRange(FIRST, dateCol,   n, 1).getValues();
  const chans   = sheet.getRange(FIRST, chanCol,   n, 1).getValues();
  const stats   = sheet.getRange(FIRST, statusCol, n, 1).getValues();
  const labels  = sheet.getRange(FIRST, labelCol,  n, 1).getValues();

  const newLabels = labels.map(r => [r[0]]);
  let changed = false;

  // ---------- helpers ----------
  const isEligible = ch => {
    const s = String(ch||"").trim().toLowerCase();
    return s === "wa/tg/sms" || s === "sms" || s === "whatsapp" || s === "telegram";
  };
  const isFrozen  = st => {
    const s = String(st||"").trim().toLowerCase();
    return s === "—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∞" || s === "–≤—ã–ø–æ–ª–Ω–µ–Ω–∞" || s === "–æ—Ç–º–µ–Ω–µ–Ω–∞";
  };
  const toDDMM = v => {
    if (Object.prototype.toString.call(v) === "[object Date]") {
      return Utilities.formatDate(v, tz, "dd.MM");
    }
    const s = String(v||"").trim();
    const m = /^(\d{2})\.(\d{2})(?:\.(\d{4}))?$/.exec(s);
    return m ? `${m[1]}.${m[2]}` : null;
  };
  const parseNum = lbl => {
    const m = /^4_\d{2}\.\d{2}_(\d+)$/.exec(String(lbl||"").trim());
    return m ? parseInt(m[1], 10) : null;
  };
  const labelDate = lbl => {
    const m = /^4_(\d{2}\.\d{2})_\d+$/.exec(String(lbl||"").trim());
    return m ? m[1] : null;
  };

  const perDay = new Map(); // ddmm -> { used:Set, kept:Set, frozenUsed:Set, reassign:[], generate:[] }
  const dayObj = d => (perDay.get(d) || (perDay.set(d, {used:new Set(), kept:new Set(), frozenUsed:new Set(), reassign:[], generate:[]}), perDay.get(d)));

  // –õ–æ–≥–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π
  const changes = []; // {row, ddmm, before, after, reason}
  const MAX_DETAIL = 200; // —Å–∫–æ–ª—å–∫–æ –ø–æ–¥—Ä–æ–±–Ω—ã—Ö –∑–∞–ø–∏—Å–µ–π –ø–µ—á–∞—Ç–∞—Ç—å –≤ Logger

  // ---------- Step 0: –æ—á–∏—Å—Ç–∫–∞ —É –Ω–µ–∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—ã—Ö (–Ω–µ—Ü–µ–ª–µ–≤–æ–π –∫–∞–Ω–∞–ª / –Ω–µ—Ç –¥–∞—Ç—ã) ----------
  for (let i = 0; i < n; i++) {
    const eligible = isEligible(chans[i][0]);
    const ddmm = toDDMM(dates[i][0]);
    const frozen = isFrozen(stats[i][0]);
    if (!frozen && (!eligible || !ddmm)) {
      const before = String(newLabels[i][0] || "");
      if (before) {
        newLabels[i][0] = "";
        changed = true;
        changes.push({
          row: FIRST + i,
          ddmm: ddmm || "-",
          before,
          after: "",
          reason: "cleared_ineligible_or_no_date"
        });
      }
    }
  }

  // ---------- Step 1: frozen –∑–∞–Ω–∏–º–∞—é—Ç –Ω–æ–º–µ—Ä–∞ ----------
  for (let i = 0; i < n; i++) {
    const ddmm = toDDMM(dates[i][0]);
    if (!ddmm) continue;
    if (!isEligible(chans[i][0])) continue;

    if (isFrozen(stats[i][0])) {
      const num = parseNum(newLabels[i][0]);
      const ld  = labelDate(newLabels[i][0]);
      if (num != null && ld === ddmm) {
        const d = dayObj(ddmm);
        d.used.add(num);
        d.frozenUsed.add(num); // –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∑–∞–Ω—è—Ç—ã–π –∏–º–µ–Ω–Ω–æ frozen
      }
    }
  }

  // ---------- Step 2: –Ω–µ–∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—ã–µ: –∫—Ç–æ –æ—Å—Ç–∞—ë—Ç—Å—è, –∫—Ç–æ –≤ –æ—á–µ—Ä–µ–¥—å ----------
  for (let i = 0; i < n; i++) {
    const ddmm = toDDMM(dates[i][0]);
    if (!ddmm) continue;
    if (!isEligible(chans[i][0])) continue;
    if (isFrozen(stats[i][0])) continue;

    const d = dayObj(ddmm);
    const cur = String(newLabels[i][0] || "").trim();
    const num = parseNum(cur);
    const ld  = labelDate(cur);
    const valid = (num != null) && (ld === ddmm);

    if (valid && !d.used.has(num) && !d.kept.has(num)) {
      // –ø–µ—Ä–≤—ã–π –Ω–µ–∑–∞–º–æ—Ä–æ–∂–µ–Ω–Ω—ã–π –≤–ª–∞–¥–µ–ª–µ—Ü –Ω–µ–∑–∞–Ω—è—Ç–æ–≥–æ –Ω–æ–º–µ—Ä–∞ ‚Äî –æ—Å—Ç–∞–≤–ª—è–µ–º
      d.used.add(num);
      d.kept.add(num);
    } else if (valid) {
      // –¥—É–±–ª–∏–∫–∞—Ç –ª–∏–±–æ –∫–æ–Ω—Ñ–ª–∏–∫—Ç —Å frozen
      d.reassign.push({
        i,
        old: cur,
        num,
        conflictFrozen: d.frozenUsed.has(num)
      });
    } else {
      // –ø—É—Å—Ç–∞—è/–Ω–µ–≤–∞–ª–∏–¥–Ω–∞—è/—á—É–∂–∞—è –¥–∞—Ç–∞
      d.generate.push({
        i,
        old: cur
      });
    }
  }

  // ---------- Step 3: –≤—ã–¥–∞—ë–º —Å–≤–æ–±–æ–¥–Ω—ã–µ –Ω–æ–º–µ—Ä–∞ —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ ----------
  const nextFree = set => { let k = 1; while (set.has(k)) k++; set.add(k); return k; };

  perDay.forEach((bucket, ddmm) => {
    const { used, reassign, generate } = bucket;
    // –ü–æ—Ä—è–¥–æ–∫: —Å–Ω–∞—á–∞–ª–∞ —á–∏–Ω–∏–º –¥—É–±–ª–∏–∫–∞—Ç—ã, –ø–æ—Ç–æ–º –≥–µ–Ω–µ—Ä–∏–º –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–µ
    const queue = [
      ...reassign.map(x => ({...x, kind: "reassign"})),
      ...generate.map(x => ({...x, kind: "generate"}))
    ].sort((a,b)=>a.i - b.i);

    for (const item of queue) {
      const i = item.i;
      const before = String(newLabels[i][0] || "");
      const num = nextFree(used);
      const after = `4_${ddmm}_${num}`;
      if (before !== after) {
        newLabels[i][0] = after;
        changed = true;
        const reason =
          item.kind === "reassign"
            ? (item.conflictFrozen ? "reassigned_conflict_frozen" : "reassigned_duplicate")
            : "generated_missing_or_invalid";
        changes.push({ row: FIRST + i, ddmm, before, after, reason });
      }
    }
  });

  // ---------- –ó–∞–ø–∏—Å—å –∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ ----------
  if (changed) {
    sheet.getRange(FIRST, labelCol, n, 1).setValues(newLabels);
  }

  // –°–≤–æ–¥–∫–∞ –ø–æ –¥–∞—Ç–∞–º/–ø—Ä–∏—á–∏–Ω–∞–º
  const byDay = {};
  for (const ch of changes) {
    const key = ch.ddmm;
    if (!byDay[key]) byDay[key] = {reassigned_conflict_frozen:0, reassigned_duplicate:0, generated_missing_or_invalid:0, cleared_ineligible_or_no_date:0};
    byDay[key][ch.reason] = (byDay[key][ch.reason] || 0) + 1;
  }

  Logger.log(`üîß process_lable repair (${sheet.getName()}): changed=${changed ? changes.length : 0}`);
  Object.keys(byDay).sort().forEach(ddmm => {
    const s = byDay[ddmm];
    Logger.log(`  ‚Ä¢ ${ddmm}: reassign_conf_frozen=${s.reassigned_conflict_frozen||0}, reassign_dup=${s.reassigned_duplicate||0}, generated=${s.generated_missing_or_invalid||0}, cleared=${s.cleared_ineligible_or_no_date||0}`);
  });

  // –î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è (–Ω–µ –±–æ–ª–µ–µ MAX_DETAIL —Å—Ç—Ä–æ–∫)
  const detailCnt = Math.min(changes.length, MAX_DETAIL);
  for (let i = 0; i < detailCnt; i++) {
    const c = changes[i];
    Logger.log(`    #${i+1}: R${c.row} [${c.ddmm}] ${c.before || "‚àÖ"} ‚Üí ${c.after || "‚àÖ"} (${c.reason})`);
  }
  if (changes.length > MAX_DETAIL) {
    Logger.log(`    ‚Ä¶ truncated: ${changes.length - MAX_DETAIL} more changes`);
  }

  if (!changed) {
    Logger.log(`‚úÖ process_lable OK: ${sheet.getName()} (–Ω–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏–π)`);
  } else {
    Logger.log(`üß© process_lable repaired: ${sheet.getName()} (total ${changes.length})`);
  }
}




function isEligibleChannel_(ch) {
  const s = (ch || "").toString().trim().toLowerCase();
  return s === "wa/tg/sms" || s === "sms" || s === "whatsapp" || s === "telegram";
}
function isFrozenStatus_(st) {
  const s = (st || "").toString().trim().toLowerCase();
  return s === "—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∞" || s === "–≤—ã–ø–æ–ª–Ω–µ–Ω–∞" || s === "–æ—Ç–º–µ–Ω–µ–Ω–∞";
}
function toDDMM_(v, tz) {
  // –î–∞—Ç–∞-–æ–±—ä–µ–∫—Ç ‚Üí dd.MM
  if (Object.prototype.toString.call(v) === "[object Date]") {
    return Utilities.formatDate(v, tz || Session.getScriptTimeZone(), "dd.MM");
  }
  // –°—Ç—Ä–æ–∫–∏ –≤–∏–¥–∞ 11.08.2025 –∏–ª–∏ 11.08 ‚Üí dd.MM
  const str = (v || "").toString().trim();
  const m = /^(\d{2})\.(\d{2})(?:\.(\d{4}))?$/.exec(str);
  if (m) return `${m[1]}.${m[2]}`;
  return null;
}
function parseLabelNum_(lbl) {
  const m = /^4_\d{2}\.\d{2}_(\d+)$/.exec((lbl || "").toString().trim());
  return m ? parseInt(m[1], 10) : null;
}
function ddmmFromLabel_(lbl) {
  const m = /^4_(\d{2}\.\d{2})_\d+$/.exec((lbl || "").toString().trim());
  return m ? m[1] : null;
}


