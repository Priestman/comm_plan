function regenerateDuplicateCommunicationIds() {
  Logger.log("üöÄ [START] regenerateDuplicateCommunicationIds");

  const scriptProperties = PropertiesService.getScriptProperties();
  const kpsJson = scriptProperties.getProperty("active_kps");
  if (!kpsJson) {
    Logger.log("‚ö† –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ö–ü –≤ Script Properties.");
    return;
  }

  const kps = JSON.parse(kpsJson);
  const now = new Date();
  const timeZone = Session.getScriptTimeZone();
  const currentMonth = Utilities.formatDate(now, timeZone, "MMMM_yyyy");
  const prevDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const previousMonth = Utilities.formatDate(prevDate, timeZone, "MMMM_yyyy");

  const headerMap = getHeaderMap();
  const valueMap = getValueMap();

  let updatedCount = 0;

  kps.forEach(kp => {
    try {
      Logger.log(`üìÇ –ö–ü: ${kp.name}`);
      const file = SpreadsheetApp.openById(kp.id_work);
      const sheets = file.getSheets();

      sheets.forEach(sheet => {
        const sheetName = sheet.getName();
        const validPattern = /^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/;

        if (!validPattern.test(sheetName) || ![currentMonth, previousMonth].includes(sheetName)) return;

        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        Logger.log("üìù –ó–∞–≥–æ–ª–æ–≤–∫–∏ –ª–∏—Å—Ç–∞: " + JSON.stringify(headers));

        const headerIndices = getHeaderIndices(headers, headerMap);
        const { idCol, correctnessCol } = headerIndices;

        Logger.log(`üîç –ò–Ω–¥–µ–∫—Å—ã –∫–æ–ª–æ–Ω–æ–∫ - ID: ${idCol}, Correctness: ${correctnessCol}`);

        if (idCol < 1 || correctnessCol < 1) {
          Logger.log(`‚ö†Ô∏è –õ–∏—Å—Ç '${sheetName}' –ø—Ä–æ–ø—É—â–µ–Ω –∏–∑-–∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –∫–æ–ª–æ–Ω–æ–∫`);
          return;
        }

        const lastRow = sheet.getLastRow();
        if (lastRow < 2) return;

        const data = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn()).getValues();
        const idMap = new Map();
        const updates = [];

        data.forEach((row, i) => {
          const commId = row[idCol - 1];
          const statusRaw = row[correctnessCol - 1];
          const status = toRusValue(statusRaw?.toString().trim(), valueMap);

          if (!commId) return;

          if (!idMap.has(commId)) {
            idMap.set(commId, { count: 1, rows: [{ index: i, status }] });
          } else {
            const entry = idMap.get(commId);
            entry.count++;
            entry.rows.push({ index: i, status });
          }
        });

        idMap.forEach((entry, commId) => {
          if (entry.count < 2) return;

          const hasTransferred = entry.rows.some(r => r.status === "–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ –ë–î");
          const nonTransferred = entry.rows.filter(r => r.status !== "–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ –ë–î");
          const transferred = entry.rows.filter(r => r.status === "–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ –ë–î");

          if (hasTransferred && nonTransferred.length > 0) {
            nonTransferred.forEach(row => {
              let newId;
              do {
                newId = generateUniqueHash();
              } while (idMap.has(newId));

              updates.push({ row: row.index + 2, newId });
              idMap.set(newId, { count: 1, rows: [{ index: row.index, status: row.status }] });
              updatedCount++;
              Logger.log(`üîÑ –û–±–Ω–æ–≤–ª—ë–Ω –¥—É–±–ª–∏–∫–∞—Ç –≤ —Å—Ç—Ä–æ–∫–µ ${row.index + 2}: ${newId}`);
            });
          } else if (nonTransferred.length > 1) {
            const row = nonTransferred[0];
            let newId;
            do {
              newId = generateUniqueHash();
            } while (idMap.has(newId));

            updates.push({ row: row.index + 2, newId });
            idMap.set(newId, { count: 1, rows: [{ index: row.index, status: row.status }] });
            updatedCount++;
            Logger.log(`üîÑ –û–±–Ω–æ–≤–ª—ë–Ω –¥—É–±–ª–∏–∫–∞—Ç –≤ —Å—Ç—Ä–æ–∫–µ ${row.index + 2}: ${newId}`);
          } else if (transferred.length > 1) {
            Logger.log(`‚ö† –ù–∞–π–¥–µ–Ω—ã 2+ '–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ –≤ –ë–î' —Å ID ${commId} –Ω–∞ —Å—Ç—Ä–æ–∫–∞—Ö: ${transferred.map(r => r.index + 2).join(", ")}`);
          }
        });

        updates.forEach(update => {
          sheet.getRange(update.row, idCol).setValue(update.newId);
        });

        if (updates.length > 0) {
          Logger.log(`‚úÖ –í –ª–∏—Å—Ç–µ '${sheetName}' –æ–±–Ω–æ–≤–ª–µ–Ω–æ ${updates.length} ID`);
        } else {
          Logger.log(`‚Ñπ –õ–∏—Å—Ç '${sheetName}': –¥—É–±–ª–∏–∫–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã`);
        }
      });

    } catch (error) {
      Logger.log(`‚ùå –û—à–∏–±–∫–∞ –≤ –ö–ü '${kp.name}': ${error}`);
    }
  });

  Logger.log(`üéØ [END] –ì–æ—Ç–æ–≤–æ. –í—Å–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–æ communication_id: ${updatedCount}`);
}

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–æ–≤ –∫–æ–ª–æ–Ω–æ–∫
function getHeaderIndices(headers, headerMap) {
  const findIndex = (name) => {
    const engIndex = headers.indexOf(name);
    const rusHeader = toRusHeader(name, headerMap);
    const rusIndex = headers.indexOf(rusHeader);
    return engIndex >= 0 ? engIndex + 1 : (rusIndex >= 0 ? rusIndex + 1 : -1);
  };

  return {
    idCol: findIndex("communication_id"),
    correctnessCol: findIndex("Row Status")
  };
}

// –§—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ communication_id
function generateUniqueHash() {
  var hashBase = new Date().getTime() + "_" + Math.random();
  var hash = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_1, hashBase))
    .replace(/[^a-zA-Z0-9]/g, '');
  return hash;
}

// –ó–∞–≥—Ä—É–∑–∫–∞ header_map_eng_to_rus
function getHeaderMap() {
  const json = PropertiesService.getScriptProperties().getProperty('header_map_eng_to_rus');
  return json ? JSON.parse(json) : {};
}

// –ó–∞–≥—Ä—É–∑–∫–∞ value_map_eng_to_rus
function getValueMap() {
  const json = PropertiesService.getScriptProperties().getProperty('value_map_eng_to_rus');
  return json ? JSON.parse(json) : {};
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ (ENG –∏ RUS)
function toRusHeader(header, map) {
  const rusVersion = map[header];
  const engVersion = Object.keys(map).find(key => map[key] === header);
  return rusVersion || engVersion || header;
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π (ENG –∏ RUS)
function toRusValue(value, map) {
  const rusValue = map[value];
  const engValue = Object.keys(map).find(key => map[key] === value);
  return rusValue || engValue || value;
}
