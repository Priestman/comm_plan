function checkDuplicateTracks() {
  const spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  const timeZone = Session.getScriptTimeZone();
  const now = new Date();
  now.setHours(12, 0, 0, 0);

  const currentMonth = Utilities.formatDate(now, timeZone, "MMMM_yyyy");

  const prevDate = new Date(now);
  prevDate.setMonth(prevDate.getMonth() - 1);
  const previousMonth = Utilities.formatDate(prevDate, timeZone, "MMMM_yyyy");

  const nextDate = new Date(now);
  nextDate.setMonth(nextDate.getMonth() + 1);
  const nextMonth = Utilities.formatDate(nextDate, timeZone, "MMMM_yyyy");

  const monthsToCheck = [previousMonth, currentMonth, nextMonth];
  const validSheetPattern = /^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/;

  const allTracks = new Map();

  // üîπ –ó–∞–≥—Ä—É–∂–∞–µ–º –≤—Å–µ —Ç—Ä–µ–∫–∏ –∑–∞ 3 –º–µ—Å—è—Ü–∞
  monthsToCheck.forEach(month => {
    const sheet = spreadsheet.getSheetByName(month);
    if (!sheet || !validSheetPattern.test(sheet.getName())) return;

    const lastRow = sheet.getLastRow();
    if (lastRow <= 1) return;

    const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
    const trackCol = headers.indexOf("–¢—Ä–µ–∫") + 1;
    const statusCol = headers.indexOf("–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏") + 1;
    if (trackCol < 1 || statusCol < 1) return;

    const trackValues = sheet.getRange(2, trackCol, lastRow - 1, 1).getValues();
    const statusValues = sheet.getRange(2, statusCol, lastRow - 1, 1).getValues();

    trackValues.forEach((row, idx) => {
      const track = row[0]?.toString().trim();
      const status = statusValues[idx][0]?.toString().trim();

      if (!track) return;
      if (status === "–û—Ç–º–µ–Ω–µ–Ω–∞" || status === "–ù–µ —É—à–ª–∞") return;

      const normalized = extractTrackId_dup(track);
      if (!normalized) return;

      const trackRow = idx + 2;
      if (!allTracks.has(normalized)) allTracks.set(normalized, []);
      allTracks.get(normalized).push({ month, trackRow });
    });
  });

  // üîπ –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –ª–∏—Å—Ç
  const sheet = spreadsheet.getSheetByName(currentMonth);
  if (!sheet) return Logger.log("‚ö† –ù–µ –Ω–∞–π–¥–µ–Ω –ª–∏—Å—Ç —Ç–µ–∫—É—â–µ–≥–æ –º–µ—Å—è—Ü–∞.");

  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const trackCol = headers.indexOf("–¢—Ä–µ–∫") + 1;
  const statusCol = headers.indexOf("–°—Ç–∞—Ç—É—Å —Ä–∞—Å—Å—ã–ª–∫–∏") + 1;
  const correctnessCol = headers.indexOf("–ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Å—Ç—Ä–æ–∫–∏") + 1;

  if (trackCol < 1 || statusCol < 1 || correctnessCol < 1) {
    Logger.log("‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω—ã –Ω—É–∂–Ω—ã–µ —Å—Ç–æ–ª–±—Ü—ã.");
    return;
  }

  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;

  const trackValues = sheet.getRange(2, trackCol, lastRow - 1, 1).getValues();
  const statusValues = sheet.getRange(2, statusCol, lastRow - 1, 1).getValues();
  const correctnessValues = sheet.getRange(2, correctnessCol, lastRow - 1, 1).getValues();

  for (let i = 0; i < trackValues.length; i++) {
    const rawTrack = trackValues[i][0]?.toString().trim();
    const status = statusValues[i][0]?.toString().trim();

    if (!rawTrack || status === "–û—Ç–º–µ–Ω–µ–Ω–∞" || status === "–ù–µ —É—à–ª–∞") continue;

    const normalized = extractTrackId_dup(rawTrack);
    const currentRow = i + 2;

    if (normalized) {
      const matches = allTracks.get(normalized)?.filter(entry => entry.month !== currentMonth || entry.trackRow !== currentRow);

      if (matches?.length > 0) {
        const duplicates = matches.map(m => `${m.month} (—Å—Ç—Ä–æ–∫–∞ ${m.trackRow})`).join(", ");
        correctnessValues[i][0] = `‚ùå –î—É–±–ª–∏—Ä—É—é—â–∏–π—Å—è —Ç—Ä–µ–∫ –≤ ${duplicates}`;
      }
      // ‚ùó –ï—Å–ª–∏ –¥—É–±–ª–µ–π –Ω–µ—Ç ‚Äî correctness –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
    }
  }

  sheet.getRange(2, correctnessCol, lastRow - 1, 1).setValues(correctnessValues);
  Logger.log("‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç—Ä–µ–∫–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.");
}

function extractTrackId_dup(track) {
  if (!track) return "";
  const match = track.match(/(?:\?|&)trid=([^&]+)/);
  return match ? match[1].trim() : track.trim();
}
