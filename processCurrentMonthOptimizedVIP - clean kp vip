function processCurrentMonthOptimizedVIP() {
  const fileIds = [
    '10FIafx7vbDb7ocVT9CRjja9TRzEKEgcxpvt6iIDXWdQ', // Botto*
    '1OOy5gw-y92iYwFiMoTrj8CYrXhj19-9WkuiJGbmkFjc', // P1
    '1qp14UXR-9-iHgkxOGj42jccya2yg7jYec3HgIY72Ws4', // QAZAR
    '1vR34UA3hRlFteT3WyQCu5oW-p5seu2S5ZZvgglgObcI', // Intel-telecom
    '1_uIO2zoNgSSw5Nvd-TothCconle9Lyjcn9bOVgAlFQs', // TION - —Ñ–æ—Ä–º–∞—Ç –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã –Ω–µ–≤–µ—Ä–Ω—ã–π
    '19GdxG4ds7wqkyuSFX5OGgQWProqEZFeB0cVd4VlN_5Q', // Sempico *
    '1Qzj0lSmIWPQXp_lddKXtmOtMOIyCI1l2-9VMA0JEAyM', // Miatel *
    '17AYR0R268OWMz4xmLpN3N-3FNqPd4Nr5uFpJugkk56A', // OneSim 
    '1hfDa1qy2x-B2On_r-o8LLZCfmew_5IUphgyc-LDqesg', // tele0
    '14gOJP0hVUB-_AApbcAS2hZxuh7BWY_-kSWvz4bOTqo0', // Karix
    '1X8tAyl1-ZSXSSyEZwncLa5En9hba3xyzKrVgW1RU5xM', // Whiz
    '1e9RFq2F5YDf3S03xHQ8MLTYps_-1C6kjA34aU8C7Ctk', // InfoBip
    '12uNaeNUeNrKNJl8lQuMqffc9dNZFiNS7GYzXFgMNNU8',  // Intergo
    '1AHVBiDmELq5zXu6qso0DQcy23TJ2Mi-APDLKvL-xcwQ', // Zazumedia
    '1y4Bkyh0IvSC0UTU6nhJxTB_DMPx34X1PnlnwsmJ6IAE', // –ö–∞–Ω—Ç—Ä–∏–∫–æ–º
    '17g7Q72Cd4ecTesIvRFPGwIKHEtAML5ieKiSlwFBQ2ao', // Retail
    '1lGrZpLjBOTAclruho-NNf_RgEh9r5jwLijyo4zX8mm8', // MortyMedia
    '1u4B620NoAgzWtBqlFAmcq-Qi9enJ3-sRbNUpVUR0BN0', // DEXATEL
    '13OuGvtaXj9uLgQwEr62XwGYRhG74F4x0GYuTbVT61nU', // Lexico

  ];
  const mainSheet = SpreadsheetApp.openById('1yOC7lFlwFfXgthb5irjjoJt9tMY8bS7L4FE9Tn3-ESI');
  const sheets = mainSheet.getSheets();

  const currentDate = new Date();
  const currentMonth = currentDate.getMonth();
  const currentYear = currentDate.getFullYear();
  const cutoffDate = new Date(currentDate);
  cutoffDate.setDate(currentDate.getDate() - 50);

  const startMonth = 8, startYear = 2024;
  const allExternalData = loadExternalData(fileIds);

  for (const sheet of sheets) {
    const sheetName = sheet.getName();
    const parsed = parseSheetName(sheetName);
    if (!parsed) continue;

    const { month, year } = parsed;
    if (year < startYear || (year === startYear && month < startMonth)) continue;
    if (year > currentYear || (year === currentYear && month > currentMonth)) continue;

    Logger.log(`üìÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏—Å—Ç–∞: ${sheetName}`);
    processMonthSheet(sheet, cutoffDate, allExternalData);
  }

  Logger.log("‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ process_lable");
}

function loadExternalData(fileIds) {
  const cache = [];
  for (const id of fileIds) {
    try {
      const file = SpreadsheetApp.openById(id);
      const sms = file.getSheetByName('—Å–º—Å');
      const messengers = file.getSheetByName('–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã');
      cache.push({
        sms: sms ? sms.getDataRange().getValues() : [],
        messenger: messengers ? messengers.getDataRange().getValues() : []
      });
    } catch (e) {
      Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ ${id}: ${e.message}`);
    }
  }
  return cache;
}

function processMonthSheet(sheet, cutoffDate, externalData) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const data = sheet.getDataRange().getValues();

  const idx = (name) => headers.indexOf(name);
  const colDate = 0;
  const colChannel = idx('–ö–∞–Ω–∞–ª');
  const colGEO = idx('–ì–ï–û');
  const colProcess = idx('process_lable');
  const colSent = idx('–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ');
  const colDelivered = idx('–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ');
  const colSpend = idx('–°–ø–µ–Ω–¥');

  const updates = [];

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const rowDate = new Date(row[colDate]);
    const channel = row[colChannel];
    const geoRaw = row[colGEO];
    const baseProcess = (row[colProcess] || '').toString().trim();

    // ‚¨áÔ∏è –¥–æ–±–∞–≤–∏–ª–∏ WA/TG/SMS –≤ –¥–æ–ø—É—Å—Ç–∏–º—ã–µ –∫–∞–Ω–∞–ª—ã
    if (!baseProcess || !['SMS', 'Telegram', 'Whatsapp', 'WA/TG/SMS'].includes(channel) || row[colSent] || row[colDelivered] || row[colSpend]) continue;
    if (!geoRaw || geoRaw.toString().trim() === '') continue;

    const geoString = geoRaw.toString().trim().toLowerCase();
    let geoList = [];

    if (geoString === 'ALL') {
      geoList = [baseProcess];
    } else {
        const geos = geoString
        .split(',')
        .map(g => g.trim().toLowerCase()) // üîß –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ –í–ï–†–•–ù–ò–ô —Ä–µ–≥–∏—Å—Ç—Ä
        .filter(g => g);
      geoList = geos.length <= 1
          ? [baseProcess]
          : geos.map(g => `${baseProcess}_${g}`);
    }     

    Logger.log(`üîç –°—Ç—Ä–æ–∫–∞ ${i + 1}: –∫–∞–Ω–∞–ª=${channel} | GEO=${geoString} | process_lable=${baseProcess} | –∫–ª—é—á–∏=${geoList.join(', ')}`);

    const result = findDataInExternal(externalData, geoList, channel);

    if (!result || result.b === 0 || result.c === 0 || result.i === 0) {
      if (rowDate < cutoffDate) {
        Logger.log(`‚ö†Ô∏è –°—Ç—Ä–æ–∫–∞ ${i + 1}: –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ ‚Üí —Å—Ç–∞–≤–∏–º '–û—à–∏–±–∫–∞'`);
        sheet.getRange(i + 1, colSent + 1).setValue("–û—à–∏–±–∫–∞");
      }
      continue;
    }

    // –¥–µ—Ç–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è WA/TG/SMS
    if (channel === 'WA/TG/SMS' && result.breakdown) {
      const s = result.breakdown.sms, m = result.breakdown.msg;
      Logger.log(`‚úÖ –°—Ç—Ä–æ–∫–∞ ${i + 1} ‚Üí SMS={b:${s.b}, c:${s.c}, i:${s.i}}; MSG={b:${m.b}, c:${m.c}, i:${m.i}}; TOTAL={b:${result.b}, c:${result.c}, i:${result.i}}`);
    } else {
      Logger.log(`‚úÖ –°—Ç—Ä–æ–∫–∞ ${i + 1} ‚Üí –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ=${result.b}, –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ=${result.c}, —Å–ø–µ–Ω–¥=${result.i}`);
    }

    updates.push([i + 1, result.b, result.c, result.i]);
  }

  // –ß–∞–Ω–∫–æ–≤–∞—è –∑–∞–ø–∏—Å—å (–∫–∞–∫ –±—ã–ª–æ)
  for (const [row, valB, valC, valI] of updates) {
    sheet.getRange(row, colSent + 1).setValue(valB);
    sheet.getRange(row, colDelivered + 1).setValue(valC);
    sheet.getRange(row, colSpend + 1).setValue(valI);
  }

  Logger.log(`üìä –û–±–Ω–æ–≤–ª–µ–Ω–æ —Å—Ç—Ä–æ–∫: ${updates.length}`);
}

/**
 * –ò—â–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø–æ –∫–ª—é—á–∞–º.
 * - –î–ª—è SMS: –≤ –ª–∏—Å—Ç–µ '—Å–º—Å'
 * - –î–ª—è Telegram/Whatsapp: –≤ –ª–∏—Å—Ç–µ '–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã'
 * - –î–ª—è WA/TG/SMS: –≤ –û–ë–û–ò–• –ª–∏—Å—Ç–∞—Ö –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –ü–ï–†–í–û–ì–û —Ñ–∞–π–ª–∞, –≥–¥–µ –Ω–∞–π–¥–µ–Ω–æ —á—Ç–æ-—Ç–æ –≤–∞–ª–∏–¥–Ω–æ–µ; —Å—É–º–º–∏—Ä—É–µ—Ç SMS+MSG.
 * ¬´–í–∞–ª–∏–¥–Ω–æ—Å—Ç—å¬ª –∫–∞–∫ —Ä–∞–Ω—å—à–µ: —Å—É–º–º–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫–∏, –≥–¥–µ b,c,i –≤—Å–µ –Ω–µ–Ω—É–ª–µ–≤—ã–µ.
 */
function findDataInExternal(allData, keys, channel) {
  const normalizedKeys = keys.map(k => k.toString().trim().toLowerCase());

  // –ø–æ–º–æ—â–Ω–∏–∫ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ –æ–¥–Ω–æ–º—É –ª–∏—Å—Ç—É
  function aggregateFromSource(source, mode /* 'SMS' | 'MSG' */) {
    let b = 0, c = 0, i = 0, valid = false;
    for (let row = 1; row < source.length; row++) {
      const rawKey = source[row][0];
      const key = rawKey ? rawKey.toString().trim().toLowerCase() : '';
      if (!key) continue;
      if (normalizedKeys.some(prefix => key.startsWith(prefix))) {
        if (mode === 'SMS') {
          let bVal = normalizeNumber(source[row][1] || 0);
          let cVal = normalizeNumber(source[row][2] || 0);
          let iVal = normalizeNumber(source[row][8] || 0);
          if (bVal && cVal && iVal) { b += bVal; c += cVal; i += iVal; valid = true; }
        } else { // 'MSG' (–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã)
          let bVal = normalizeNumber(source[row][3] || 0);
          let cVal = normalizeNumber(source[row][3] || 0); // –∫–∞–∫ –±—ã–ª–æ: Delivered == Sent
          let iVal = normalizeNumber(source[row][4] || 0);
          if (bVal && cVal && iVal) { b += bVal; c += cVal; i += iVal; valid = true; }
        }
      }
    }
    return { b, c, i, valid };
  }

  for (const { sms, messenger } of allData) {
    if (channel === 'SMS') {
      const agg = aggregateFromSource(sms, 'SMS');
      if (agg.valid) return { b: agg.b, c: agg.c, i: agg.i };
    } else if (channel === 'Telegram' || channel === 'Whatsapp') {
      const agg = aggregateFromSource(messenger, 'MSG');
      if (agg.valid) return { b: agg.b, c: agg.c, i: agg.i };
    } else if (channel === 'WA/TG/SMS') {
      const aggSms = aggregateFromSource(sms, 'SMS');
      const aggMsg = aggregateFromSource(messenger, 'MSG');

      // –≤–∞–ª–∏–¥–Ω–æ, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –ª–∏—Å—Ç –¥–∞–ª –≤–∞–ª–∏–¥–Ω—É—é —Å—É–º–º—É (–ø—Ä–∞–≤–∏–ª–æ 3)
      if (aggSms.valid || aggMsg.valid) {
        const totalB = aggSms.b + aggMsg.b;
        const totalC = aggSms.c + aggMsg.c; // –¥–ª—è MSG c == b, —É–∂–µ —É—á—Ç–µ–Ω–æ
        const totalI = aggSms.i + aggMsg.i;

        return {
          b: totalB,
          c: totalC,
          i: totalI,
          breakdown: {
            sms: { b: aggSms.b, c: aggSms.c, i: aggSms.i },
            msg: { b: aggMsg.b, c: aggMsg.c, i: aggMsg.i }
          }
        };
      }
      // –µ—Å–ª–∏ –≤ —ç—Ç–æ–º —Ñ–∞–π–ª–µ –æ–±–∞ –Ω–µ–≤–∞–ª–∏–¥–Ω—ã ‚Äî –∏–¥—ë–º –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —Ñ–∞–π–ª—É (–ø—Ä–∞–≤–∏–ª–æ ¬´–ø–µ—Ä–≤—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π¬ª)
    }
  }
  return null;
}

function parseSheetName(sheetName) {
  const match = sheetName.match(/^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/);
  if (!match) return null;
  const months = {
    "January": 0, "February": 1, "March": 2, "April": 3, "May": 4,
    "June": 5, "July": 6, "August": 7, "September": 8,
    "October": 9, "November": 10, "December": 11
  };
  return { month: months[match[1]], year: parseInt(match[2]) };
}

function normalizeNumber(value) {
  if (typeof value !== 'string') value = value.toString();
  return parseFloat(value.replace(/\s/g, '').replace(',', '.'));
}
