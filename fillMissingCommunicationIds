function fillMissingCommunicationIds() {
  const scriptProperties = PropertiesService.getScriptProperties();
  const kpsJson = scriptProperties.getProperty("active_kps");
  if (!kpsJson) return Logger.log("âš  ÐÐµÑ‚ Ð°ÐºÑ‚Ð¸Ð²Ð½Ñ‹Ñ… ÐšÐŸ Ð² Script Properties.");

  const kps = JSON.parse(kpsJson);
  let processedCount = 0;

  const now = new Date();
  const timeZone = Session.getScriptTimeZone();
  const currentMonth = Utilities.formatDate(now, timeZone, "MMMM_yyyy");
  const prevDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
  const previousMonth = Utilities.formatDate(prevDate, timeZone, "MMMM_yyyy");

  const headerMap = getHeaderMap();
  const valueMap = getValueMap();

  Logger.log("ðŸ“¦ Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½ headerMap: " + JSON.stringify(headerMap));
  Logger.log("ðŸ“¦ Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½ valueMap: " + JSON.stringify(valueMap));

  kps.forEach(kp => {
    try {
      Logger.log("ðŸ“Œ ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° ÐšÐŸ: " + kp.name);

      const workFile = SpreadsheetApp.openById(kp.id_work);
      const sheets = workFile.getSheets();

      sheets.forEach(sheet => {
        const sheetName = sheet.getName();
        const monthYearPattern = /^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/;

        if (!monthYearPattern.test(sheetName) || ![currentMonth, previousMonth].includes(sheetName)) {
          Logger.log("ðŸ›‘ Ð›Ð¸ÑÑ‚ Ð¿Ñ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½: " + sheetName);
          return;
        }

        Logger.log("âœ… ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð»Ð¸ÑÑ‚Ð°: " + sheetName);

        const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
        Logger.log("ðŸ“ Ð—Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸ Ð»Ð¸ÑÑ‚Ð°: " + JSON.stringify(headers));

        const headerToIndex = (name) => {
          const engIndex = headers.indexOf(name);
          const rusHeader = toRusHeader(name, headerMap);
          const rusIndex = headers.indexOf(rusHeader);

          Logger.log(`ðŸ” ÐŸÐ¾Ð¸ÑÐº ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸ "${name}" - ENG: ${engIndex + 1}, RUS: ${rusIndex + 1}`);
          return engIndex >= 0 ? engIndex + 1 : (rusIndex >= 0 ? rusIndex + 1 : -1);
        };

        const idCol = headerToIndex("communication_id");
        const dateCol = headerToIndex("Date");
        const trackCol = headerToIndex("Track");
        const statusCol = headerToIndex("Campaign Status");
        const correctnessCol = headerToIndex("Row Status");

        if ([idCol, dateCol, trackCol, statusCol, correctnessCol].some(c => c < 1)) {
          Logger.log("âš ï¸ ÐŸÑ€Ð¾Ð¿ÑƒÑ‰ÐµÐ½ Ð»Ð¸ÑÑ‚ " + sheetName + " Ð¸Ð·-Ð·Ð° Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²Ð¸Ñ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ñ… ÐºÐ¾Ð»Ð¾Ð½Ð¾Ðº");
          return;
        }

        const lastRow = sheet.getLastRow();
        if (lastRow < 2) {
          Logger.log("âš ï¸ Ð›Ð¸ÑÑ‚ " + sheetName + " Ð¿ÑƒÑÑ‚Ð¾Ð¹, Ð¿Ñ€Ð¾Ð¿ÑƒÑÐº...");
          return;
        }

        const data = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn()).getValues();
        const correctnessRange = sheet.getRange(2, correctnessCol, lastRow - 1, 1);
        const correctnessValues = correctnessRange.getValues();

        let updated = false;

        for (let i = 0; i < data.length; i++) {
          const id = data[i][idCol - 1];
          const date = data[i][dateCol - 1];
          const track = data[i][trackCol - 1];
          const statusRaw = data[i][statusCol - 1]?.toString().trim();
          const status = toRusValue(statusRaw, valueMap);

          if (status !== "Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð°" || id) continue;

          if (Object.prototype.toString.call(date) === "[object Date]" && track?.toString().trim()) {
            const newId = generateUniqueHashMis();
            data[i][idCol - 1] = newId;
            processedCount++;

            try {
              sheet.getRange(i + 2, idCol).setValue(newId);
              Logger.log("ðŸ†• ÐÐ¾Ð²Ñ‹Ð¹ communication_id Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½: " + newId + " Ð² ÑÑ‚Ñ€Ð¾ÐºÐµ " + (i + 2));
            } catch (error) {
              correctnessValues[i][0] = "ÐžÑˆÐ¸Ð±ÐºÐ° Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ð¸ communication_id";
              Logger.log("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ¸ communication_id: " + error);
            }

            updated = true;
          }
        }

        if (updated) {
          correctnessRange.setValues(correctnessValues);
          Logger.log("âœ… ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ñ‹ Ð´Ð»Ñ Ð»Ð¸ÑÑ‚Ð°: " + sheetName);
        }
      });
    } catch (err) {
      Logger.log("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð² ÐšÐŸ " + kp.name + ": " + err);
    }
  });

  Logger.log("ðŸŽ¯ communication_id Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ‹: " + processedCount);
}

// Ð¤ÑƒÐ½ÐºÑ†Ð¸Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ ÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ð¾Ð³Ð¾ communication_id
function generateUniqueHashMis() {
  var hashBase = new Date().getTime() + "_" + Math.random();
  var hash = Utilities.base64Encode(Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_1, hashBase))
    .replace(/[^a-zA-Z0-9]/g, '');
  return hash;
}

// Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° header_map_eng_to_rus
function getHeaderMap() {
  const json = PropertiesService.getScriptProperties().getProperty('header_map_eng_to_rus');
  return json ? JSON.parse(json) : {};
}

// Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° value_map_eng_to_rus
function getValueMap() {
  const json = PropertiesService.getScriptProperties().getProperty('value_map_eng_to_rus');
  return json ? JSON.parse(json) : {};
}

// ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¾Ð² (ENG Ð¸ RUS)
function toRusHeader(header, map) {
  const rusVersion = map[header];
  const engVersion = Object.keys(map).find(key => map[key] === header);
  return rusVersion || engVersion || header;
}

// ÐŸÑ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹ (ENG Ð¸ RUS)
function toRusValue(value, map) {
  const rusValue = map[value];
  const engValue = Object.keys(map).find(key => map[key] === value);
  return rusValue || engValue || value;
}
