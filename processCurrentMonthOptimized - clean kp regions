function processCurrentMonthOptimized() {
  const fileIds = [
    '10FIafx7vbDb7ocVT9CRjja9TRzEKEgcxpvt6iIDXWdQ', // Botto*
    '1OOy5gw-y92iYwFiMoTrj8CYrXhj19-9WkuiJGbmkFjc', // P1
    '1qp14UXR-9-iHgkxOGj42jccya2yg7jYec3HgIY72Ws4', // QAZAR
    '1vR34UA3hRlFteT3WyQCu5oW-p5seu2S5ZZvgglgObcI', // Intel-telecom
    '1_uIO2zoNgSSw5Nvd-TothCconle9Lyjcn9bOVgAlFQs', // TION - —Ñ–æ—Ä–º–∞—Ç –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã –Ω–µ–≤–µ—Ä–Ω—ã–π
    '19GdxG4ds7wqkyuSFX5OGgQWProqEZFeB0cVd4VlN_5Q', // Sempico *
    '1Qzj0lSmIWPQXp_lddKXtmOtMOIyCI1l2-9VMA0JEAyM', // Miatel *
    '17AYR0R268OWMz4xmLpN3N-3FNqPd4Nr5uFpJugkk56A', // OneSim
    '1hfDa1qy2x-B2On_r-o8LLZCfmew_5IUphgyc-LDqesg', // tele0
    '14gOJP0hVUB-_AApbcAS2hZxuh7BWY_-kSWvz4bOTqo0', // Karix
    '1X8tAyl1-ZSXSSyEZwncLa5En9hba3xyzKrVgW1RU5xM', // Whiz
    '1e9RFq2F5YDf3S03xHQ8MLTYps_-1C6kjA34aU8C7Ctk', // InfoBip
    '12uNaeNUeNrKNJl8lQuMqffc9dNZFiNS7GYzXFgMNNU8',  // Intergo
    '1AHVBiDmELq5zXu6qso0DQcy23TJ2Mi-APDLKvL-xcwQ', // Zazumedia
    '1y4Bkyh0IvSC0UTU6nhJxTB_DMPx34X1PnlnwsmJ6IAE', // –ö–∞–Ω—Ç—Ä–∏–∫–æ–º
    '17g7Q72Cd4ecTesIvRFPGwIKHEtAML5ieKiSlwFBQ2ao', // Retail
    '1u4B620NoAgzWtBqlFAmcq-Qi9enJ3-sRbNUpVUR0BN0', // DEXATEL
    '13OuGvtaXj9uLgQwEr62XwGYRhG74F4x0GYuTbVT61nU', // Lexico
    '1lGrZpLjBOTAclruho-NNf_RgEh9r5jwLijyo4zX8mm8' // MortyMedia'
    
  ];

  const mainSheet = SpreadsheetApp.openById('1WfslprOxh0UTQhkr1qjTRIEeTG56moyAlAK3NAnffrg');
  const sheets = mainSheet.getSheets();

  const currentDate = new Date();
  const currentMonth = currentDate.getMonth();
  const currentYear = currentDate.getFullYear();
  const cutoffDate = new Date(currentDate);
  cutoffDate.setDate(currentDate.getDate() - 20);

  // –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ: —Ç–µ–∫—É—â–∏–π –≥–æ–¥ ‚Äî 2025, –∞ –Ω–µ 2024, –µ—Å–ª–∏ –Ω–µ –º–µ–Ω—è–ª–∏. –Ø –æ—Å—Ç–∞–≤–∏–ª –∫–∞–∫ –≤ –≤–∞—à–µ–º –∫–æ–¥–µ
  const startMonth = 8, startYear = 2024; 
  const allExternalData = loadExternalData(fileIds);

  for (const sheet of sheets) {
    const sheetName = sheet.getName();
    const parsed = parseSheetName(sheetName);
    if (!parsed) continue;

    const { month, year } = parsed;
    if (year < startYear || (year === startYear && month < startMonth)) continue;
    if (year > currentYear || (year === currentYear && month > currentMonth)) continue;

    Logger.log(`üìÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –ª–∏—Å—Ç–∞: ${sheetName}`);
    processMonthSheet(sheet, cutoffDate, allExternalData);
  }

  Logger.log("‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫ process_lable");
}

function loadExternalData(fileIds) {
  const cache = [];
  for (const id of fileIds) {
    try {
      const file = SpreadsheetApp.openById(id);
      const sms = file.getSheetByName('—Å–º—Å');
      const messengers = file.getSheetByName('–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã');
      cache.push({
        sms: sms ? sms.getDataRange().getValues() : [],
        messenger: messengers ? messengers.getDataRange().getValues() : []
      });
    } catch (e) {
      Logger.log(`‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞ ${id}: ${e.message}`);
    }
  }
  return cache;
}

function processMonthSheet(sheet, cutoffDate, externalData) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const data = sheet.getDataRange().getValues();

  const idx = (name) => headers.indexOf(name);
  const colDate = 0;
  const colChannel = idx('–ö–∞–Ω–∞–ª');
  const colGEO = idx('–ì–ï–û');
  const colProcess = idx('process_lable');
  const colSent = idx('–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ');
  const colDelivered = idx('–î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ');
  const colSpend = idx('–°–ø–µ–Ω–¥');

  const updates = [];

  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    const rowDate = new Date(row[colDate]);
    const channel = row[colChannel];
    const geoRaw = row[colGEO];
    const baseProcess = (row[colProcess] || '').toString().trim();

    // ‚û°Ô∏è –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω 'KakaoTalk' –≤ —Å–ø–∏—Å–æ–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º—ã—Ö –∫–∞–Ω–∞–ª–æ–≤
    if (!baseProcess || !['SMS', 'Telegram', 'Whatsapp', 'Viber', 'KakaoTalk'].includes(channel) || row[colSent] || row[colDelivered] || row[colSpend]) continue;
    if (!geoRaw || geoRaw.toString().trim() === '') continue;

    const geoString = geoRaw.toString().trim().toUpperCase();
    let geoList = [];

    if (geoString === 'ALL') {
      geoList = [baseProcess];
    } else {
      const geos = geoString.split(',').map(g => g.trim()).filter(g => g);
      if (geos.length <= 1) {
        geoList = [baseProcess];
      } else {
        geoList = geos.map(g => `${baseProcess}_${g}`);
      }
    }

    Logger.log(`üîç –°—Ç—Ä–æ–∫–∞ ${i + 1}: –∫–∞–Ω–∞–ª=${channel} | GEO=${geoString} | process_lable=${baseProcess} | –∫–ª—é—á–∏=${geoList.join(', ')}`);

    const result = findDataInExternal(externalData, geoList, channel);
    if (!result || result.b === 0 || result.c === 0 || result.i === 0) {
      if (rowDate < cutoffDate) {
        Logger.log(`‚ö†Ô∏è –°—Ç—Ä–æ–∫–∞ ${i + 1}: –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ ‚Üí —Å—Ç–∞–≤–∏–º '–û—à–∏–±–∫–∞'`);
        sheet.getRange(i + 1, colSent + 1).setValue("–û—à–∏–±–∫–∞");
      }
      continue;
    }

    updates.push([i + 1, result.b, result.c, result.i]);
    Logger.log(`‚úÖ –°—Ç—Ä–æ–∫–∞ ${i + 1} ‚Üí –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ=${result.b}, –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ=${result.c}, —Å–ø–µ–Ω–¥=${result.i}`);
  }

  // –ß–∞–Ω–∫–æ–≤–∞—è –∑–∞–ø–∏—Å—å
  for (const [row, valB, valC, valI] of updates) {
    sheet.getRange(row, colSent + 1).setValue(valB);
    sheet.getRange(row, colDelivered + 1).setValue(valC);
    sheet.getRange(row, colSpend + 1).setValue(valI);
  }

  Logger.log(`üìä –û–±–Ω–æ–≤–ª–µ–Ω–æ —Å—Ç—Ä–æ–∫: ${updates.length}`);
}

function findDataInExternal(allData, keys, channel) {
  // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –∫–ª—é—á–∏ —Å—Ä–∞–∑—É (—É–¥–∞–ª—è–µ–º –ø—Ä–æ–±–µ–ª—ã, –ø—Ä–∏–≤–æ–¥–∏–º –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É)
  const normalizedKeys = keys.map(k => k.toString().trim().toLowerCase());

  // ‚û°Ô∏è –ò–ó–ú–ï–ù–ï–ù–ò–ï: –î–æ–±–∞–≤–ª–µ–Ω 'KakaoTalk' –≤ —Å–ø–∏—Å–æ–∫ –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä–æ–≤
  const isMessenger = ['Telegram', 'Whatsapp', 'Viber', 'KakaoTalk'].includes(channel);

  for (const { sms, messenger } of allData) {
    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∏—Å—Ç–æ—á–Ω–∏–∫: '—Å–º—Å' –¥–ª—è SMS, '–ú–µ—Å—Å–µ–Ω–¥–∂–µ—Ä—ã' –¥–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö
    const source = channel === 'SMS' ? sms : messenger; 
    let b = 0, c = 0, i = 0, valid = false;

    for (let row = 1; row < source.length; row++) {
      const rawKey = source[row][0];
      const key = rawKey ? rawKey.toString().trim().toLowerCase() : '';
      if (normalizedKeys.some(prefix => key.startsWith(prefix))) {
        if (channel === 'SMS') {
          let bVal = normalizeNumber(source[row][1] || 0); // –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ
          let cVal = normalizeNumber(source[row][2] || 0); // –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ
          let iVal = normalizeNumber(source[row][8] || 0); // –°–ø–µ–Ω–¥
          if (bVal && cVal && iVal) {
            b += bVal; c += cVal; i += iVal; valid = true;
          }
        } else if (isMessenger) {
          // –õ–æ–≥–∏–∫–∞ –¥–ª—è –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä–æ–≤ (Telegram, Whatsapp, Viber, KakaoTalk)
          let bVal = normalizeNumber(source[row][3] || 0); // –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ (–ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ)
          let cVal = normalizeNumber(source[row][3] || 0); // –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ (–ø–æ–≤—Ç–æ—Ä—è–µ—Ç –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ - –∫–æ–ª–æ–Ω–∫–∞ 3)
          let iVal = normalizeNumber(source[row][4] || 0); // –°–ø–µ–Ω–¥
          if (bVal && cVal && iVal) {
            b += bVal; c += cVal; i += iVal; valid = true;
          }
        }
      }
    }
    if (valid) return { b, c, i };
  }
  return null;
}

function parseSheetName(sheetName) {
  const match = sheetName.match(/^(January|February|March|April|May|June|July|August|September|October|November|December)_(\d{4})$/);
  if (!match) return null;
  const months = {
    "January": 0, "February": 1, "March": 2, "April": 3, "May": 4,
    "June": 5, "July": 6, "August": 7, "September": 8,
    "October": 9, "November": 10, "December": 11
  };
  return { month: months[match[1]], year: parseInt(match[2]) };
}

function normalizeNumber(value) {
  if (typeof value !== 'string') value = value.toString();
  return parseFloat(value.replace(/\s/g, '').replace(',', '.'));
}
